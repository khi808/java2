JVM 메모리 분류
1. 메소드영역 static // 정적 = 프로그램이 종료될때 까지 사용됨, 특징 = 1. 공용으로 사용함 2. 제일먼저 할당됨 ex)main메소드 static변수 
String값 constant pool=리터럴 상수값
2. 변수영역 stack // 동적 = 코드가 실행되고 사라짐 지역변수 , 매개 변수 
3. 객체영역 heap // 동적 가지비 콜렉터가 메모리 회수 ex) 생성자를 이용해서 객체생성시 이쪽에 생성됨 new == heap을 사용하겠다.

// 강제로 예외발생법
throw new Exception();

//오버라이딩 불가 메소드
1. static 메소드 -> 클래스에 종속됨.
2. private 메소드 -> 상속 안됨.
3. final 메소드 -> 변경 불가.

//접근유효범위
private 멤버(필드,메소드) - 전부 접근불가
public 멤버(필드,메소드) - 전부 접근가능
default 멤버(필드,메소드) -  같은 패키지 내에서만 접근가능
protected 멤버(필드,메소드) - 같인 패키지와 다른패키지의 자식클래스(상속받은)만 접근가능

//객체의 타입변환
자식객체를 부모타입에 대입가능

//정적 import문
클래스명 없이 메소드를 사용가능하다.
import문 사용법 -> 클래스명.메소드();
정적 import문 사용법 -> 메소드();

// 객체 변환가능 확인
변환객체 instanceof 변환할객체 = 변환객체에서 변환할객체로 타입을 바꿀수 있으면 true를 반환함 
// 최상위 객체로 변환후 다시 하위객체로 변환할때 오류를 일으키지 않으려고 사용함
ex ) car instanceof bus 의 리턴되는 값은 true
변환객체는 부모객체이고 변환할객체는 자식객체

eclipse 초기설정 
1. window 메뉴 - preferences - workspace - text encoding utf-8 바꿀것 , window title 전부체크

// 다형성 - 부모객체에 자식객체, 즉 최상위객체에 하위객체 대입가능
// 1. 최상위 객체에는 하위객체를 대입가능하다. (오류를 줄이기 위해 instanceof 를 사용함)
// 2. 재정의된 메소드나 필드가 사용된다.
최상위 객체를 상속받은 하위객체를 최상위객체에 대입을 하면 
최상위 객체의 메소드와 필드에만 접근가능하고 최상위객체의 메소드를 하위객체에서 재정의했다면 그 메소드를
호출하면 오버라이딩 된 메소드가 호출이 된다.

최상위객체 = 하위객체 (promotion) 자동형변환되어 최상위객체만 사용가능.
최상위객체.메소드(); // 하위객체에서 만약 재정의를 했다면 하위객체에서 재정의한 메소드가 실행됨
최상위객체.하위객체메소드(); // 실행불가능. 최상위객체에 하위객체를 대입하면 최상위객체의 메소드만 사용가능.

//JDBC 작업 순서
1. JDBC 드라이버 로딩
2. DB연결
3. 쿼리 작업
4. DB연결 해제
//상세
1. Connection 객체 생성
2.try문안에 Class.forName("com.mysql.jdbc.Driver");
3. 쿼리작업 ( Statement, ResultSet 객체이용 )
4. Connection해제 (Statement, ResultSet 포함) - 실행 순서의 역순으로 해제하면 됨

추상 메소드와 인터페이스의 차이
추상 메소드 - 다중 상속 X
인터페이스 - 인터페이스간의 다중 상속 가능, 다중 구현 가능

